# Завдання з дослідження сегментів та часу виконання

Цей репозиторій містить рішення до завдань з дослідження сегментів виконуваних файлів та особливостей архітектури комп'ютерних систем.

## Зміст

1. [Завдання 1: Дослідження time_t](#завдання-1-дослідження-time_t)
2. [Завдання 2.2: Дослідження сегментів виконуваного файлу](#завдання-22-дослідження-сегментів-виконуваного-файлу)
3. [Завдання 2.3: Розташування стеку та сегментів](#завдання-23-розташування-стеку-та-сегментів)
4. [Завдання 2.4: Дослідження стеку процесу](#завдання-24-дослідження-стеку-процесу)
5. [Завдання 2.5: Теоретичне завдання про використання стеку](#завдання-25-теоретичне-завдання)
6. [Завдання 19: Перевірка залежностей ELF-файлів](#завдання-19-перевірка-залежностей-elf-файлів)

## Завдання 1: Дослідження time_t

### Опис
Програма визначає момент, коли `time_t` закінчиться, та досліджує відмінності в залежності від архітектури (32/64-біт).

### Запуск
```bash
gcc time_overflow.c -o time_overflow
./time_overflow
```

### Результати
- На 32-бітних системах `time_t` зазвичай має розмір 4 байти, тому переповнення настає 19 січня 2038 року (2038-01-19 03:14:07 UTC).
- На 64-бітних системах `time_t` зазвичай має розмір 8 байт, що забезпечує достатньо часу до переповнення (приблизно 292 мільярди років).

**Результати на різних платформах:**



**FreeBSD x86_64:**
```
Максимальне значення time_t: 9223372036854775807
Дата переповнення: Sun Dec 4 11:59:59 9999 UTC (або подібна далека дата)
Розмір time_t: 8 байт
Система 64-бітна.
```

**32-бітний CYGWIN на Windows:**
```
Максимальне значення time_t: 2147483647
Дата переповнення: Tue Jan 19 03:14:07 2038
Розмір time_t: 4 байт
Система 32-бітна.
```

**Примітка:** У деяких новіших версіях CYGWIN навіть на 32-бітних системах `time_t` може бути 8-байтовим цілим, але це залежить від конкретної конфігурації.

## Завдання 2.2: Дослідження сегментів виконуваного файлу

### Опис
Серія кодів для дослідження зміни розміру сегментів виконуваного файлу при різних умовах:
1. Базова програма "Hello world"
2. Додавання глобального неініціалізованого масиву
3. Додавання глобального ініціалізованого масиву
4. Додавання локальних масивів

### Запуск та дослідження
```bash
# Компіляція
gcc hello1.c -o hello1
gcc hello2.c -o hello2
gcc hello3.c -o hello3
gcc hello4.c -o hello4

# Перегляд розміру файлу
ls -l hello1 hello2 hello3 hello4

# Перегляд розмірів сегментів
size hello1 hello2 hello3 hello4

# Компіляція з налагодженням
gcc -g hello1.c -o hello1_debug
size hello1_debug

# Компіляція з оптимізацією
gcc -O3 hello1.c -o hello1_opt
size hello1_opt
```

### Очікувані результати
- Неініціалізований глобальний масив збільшує сегмент BSS
- Ініціалізований глобальний масив збільшує сегмент даних
- Локальні масиви не впливають на розмір виконуваного файлу
- Налагодження збільшує розмір файлу, але не впливає на сегменти даних/BSS
- Оптимізація зменшує розмір текстового сегменту

**Приклади виводу команди `size` на FreeBSD x86_64:**

```
# Базова програма (hello1)
text    data     bss     dec     hex filename
1267     488       8    1763     6e3 hello1

# З неініціалізованим глобальним масивом (hello2)
text    data     bss     dec     hex filename
1267     488    4008    5763    167b hello2

# З ініціалізованим глобальним масивом (hello3)
text    data     bss     dec     hex filename
1267    4488       8    5763    167b hello3
```

**Приклади виводу команди `size` на CYGWIN:**

```
# Базова програма (hello1)
text    data     bss     dec     hex filename
11456    1536    1328   14320    37f0 hello1

# З неініціалізованим глобальним масивом (hello2)
text    data     bss     dec     hex filename
11456    1536    5328   18320    4790 hello2

# З ініціалізованим глобальним масивом (hello3)
text    data     bss     dec     hex filename
11456    5536    1328   18320    4790 hello3
```

**Примітка:** На CYGWIN спостерігаються значно більші розміри сегментів через додаткові залежності Windows та різну організацію виконуваних файлів.

## Завдання 2.3: Розташування стеку та сегментів

### Опис
Програма для визначення приблизного розташування стеку, сегментів даних і тексту, а також купи в пам'яті процесу.

### Запуск
```bash
gcc memory_layout.c -o memory_layout
./memory_layout
```

### Очікувані результати

**FreeBSD x86_64:**
```
Stack variable address: 0x7fffffffe49c
Heap variable address: 0x80105e000
Global initialized variable address (.data): 0x80100420c
Global uninitialized variable address (.bss): 0x801004308
Static local variable address (.data): 0x801004210
Function (code/text) address: 0x80100119f
```

**CYGWIN:**
```
Stack variable address: 0x8fe4bff86c
Heap variable address: 0x6005a0
Global initialized variable address (.data): 0x402018
Global uninitialized variable address (.bss): 0x403030
Static local variable address (.data): 0x40201c
Function (code/text) address: 0x4010c0
```

**Примітки:**
1. В усіх випадках спостерігається, що стек розташований у високих адресах пам'яті
2. Сегменти даних (.data, .bss) та виконуваний код (.text) знаходяться в низьких адресах
3. Heap (куча) зазвичай розміщена між сегментами даних та стеком
4. На FreeBSD та Linux адреси починаються з більших значень через ASLR (Address Space Layout Randomization)
5. На CYGWIN адреси відрізняються через особливості організації пам'яті в Windows

## Завдання 2.4: Дослідження стеку процесу

### Опис
Програма для дослідження стеку процесу, включаючи вкладені виклики функцій.

### Запуск та дослідити
```bash
# Компіляція
gcc stacker.c -o stacker

# Запуск програми
./stacker &
# Запам'ятайте PID процесу

# Аналіз через gstack
gstack <PID>

# Або через GDB
gdb --quiet
(gdb) attach <PID>
(gdb) bt
```

### Очікуваний вивід програми

```
In function               main; &localvar = 0x7ffcbab70a9c
In function                foo; &localvar = 0x7ffcbab70a6c
In function                bar; &localvar = 0x7ffcbab70a3c
In function   bar_is_now_closed; &localvar = 0x7ffcbab70a0c

Now blocking on pause()...
```

### Очікуваний вивід gdb (FreeBSD)

```
(gdb) bt
#0  0x000000080109f75a in pause () from /lib/libc.so.7
#1  0x0000000000401226 in bar_is_now_closed () at stacker.c:15
#2  0x0000000000401289 in bar () at stacker.c:21
#3  0x00000000004012cc in foo () at stacker.c:27
#4  0x000000000040130e in main (argc=1, argv=0x7fffffffe520) at stacker.c:33
```

### Очікуваний вивід gdb (CYGWIN)

```
(gdb) bt
#0  0x0000000077c4d440 in KERNEL32!WaitForSingleObjectEx () from /cygdrive/c/Windows/system32/kernel32.dll
#1  0x0000000180049bbc in cygwin_crt0_common () from /usr/bin/cygwin1.dll
#2  0x0000000000401226 in bar_is_now_closed () at stacker.c:15
#3  0x0000000000401289 in bar () at stacker.c:21
#4  0x00000000004012cc in foo () at stacker.c:27
#5  0x000000000040130e in main (argc=1, argv=0x8fe4bff70) at stacker.c:33
```

**Примітки:**
1. На всіх платформах видно, що стек викликів читається знизу вгору: від main до pause()
2. Адреси локальних змінних у стеку зменшуються з кожним викликом функції, що підтверджує, що стек зростає вниз
3. У CYGWIN стек має додаткові кадри, пов'язані з реалізацією POSIX API через Windows
4. На FreeBSD видно системні виклики з libc, а на CYGWIN відображається виклик у kernel32.dll

## Завдання 2.5: Теоретичне завдання

### Питання
Чи можна при виклику процедур і поверненні з них обійтися без лічильника команд (IP), використовуючи замість нього вершину стека?

### Відповідь
У теорії, можна використовувати стек замість виділеного лічильника команд для керування потоком виконання програми, але це має суттєві обмеження:

1. **Обмеження на структуру програми**: програма могла б виконувати тільки послідовні блоки коду, з викликами процедур, без умовних переходів, циклів або інших конструкцій керування потоком.

2. **Обмеження на архітектуру**: процесор повинен мати доступ до вершини стеку для визначення наступної команди, що суперечить принципу розділення даних та інструкцій.

3. **Проблеми продуктивності**: постійне читання адрес з пам'яті (стеку) замість використання спеціалізованого регістра знизить продуктивність.

4. **Складність реалізації винятків**: обробка помилок та виключних ситуацій була б надзвичайно складною.

Тому, хоча теоретично можливо замінити IP стеком у дуже обмежених сценаріях, на практиці це призвело б до надто обмеженої та неефективної архітектури.

## Завдання 19: Перевірка залежностей ELF-файлів

### Опис
Програма для перевірки залежностей ELF-файлів, включаючи аналіз заголовка ELF, динамічних залежностей та імпортованих символів.


### Запуск
```bash
gcc elf_dependencies.c -o elf_checker
./elf_checker /bin/ls     # Можна вказати будь-який ELF-файл
```

### Що показує програма
- Інформацію про ELF-заголовок (тип файлу, архітектура, точка входу)
- Список динамічних залежностей (shared libraries)
- Список імпортованих символів

### Приклад виводу на FreeBSD (x86_64)

```
=== Analyzing /bin/ls ===
ELF Header:
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1
  OS/ABI:                            UNIX - System V
  Type:                              EXEC (Executable file)
  Machine:                           AMD x86-64
  Entry point address:               0x20199c
  Start of program headers:          64 (bytes into file)
  Start of section headers:          33792 (bytes into file)
  Number of program headers:         7
  Number of section headers:         36
  Section header string table index: 35

Dynamic Dependencies:
  libc.so.7
  libcrypt.so.5

Imported Symbols:
  strftime
  ctime
  getopt
  getenv
  ...
```

### CYGWIN і ELF-файли

На CYGWIN програма буде працювати з двома типами файлів:

1. Власними CYGWIN ELF-файлами (наприклад, `/bin/ls.exe`):
   ```
   === Analyzing /bin/ls.exe ===
   ELF Header:
     Class:                             ELF64
     Data:                              2's complement, little endian
     Version:                           1
     OS/ABI:                            UNIX - System V
     Type:                              DYN (Shared object file)
     Machine:                           AMD x86-64
     
   Dynamic Dependencies:
     cygwin1.dll
     ...
   ```

2. Для стандартних Windows PE-файлів програма повідомить, що файл не є ELF:
   ```
   === Analyzing C:\Windows\System32\notepad.exe ===
   C:\Windows\System32\notepad.exe is not an ELF file
   ```

**Примітка:** На CYGWIN більшість виконуваних файлів використовують тип DYN (shared object) замість EXEC, оскільки вони розроблені як позиційно-незалежний код.

## Висновки
У результаті виконання всіх завдань вдалося краще зрозуміти, як працює пам’ять у процесі, зокрема як розміщуються різні сегменти (текст, дані, BSS, стек, куча), як змінюється структура виконуваного файлу залежно від використаних змінних, а також як виглядає стек викликів під час роботи програми. Крім того, ми дослідили, як архітектура системи впливає на типи даних (наприклад, time_t) та які бібліотеки підключаються до ELF-файлів. Ці спостереження дозволяють краще розуміти внутрішню організацію виконуваних програм, що важливо як для розробників, так і для фахівців з низькорівневого аналізу систем.