# Дослідження сегментів та часу виконання

Рішення завдань з аналізу архітектури та сегментів виконуваних файлів.

## Завдання 1: Дослідження time_t

- **Мета**: визначення моменту переповнення `time_t` на різних архітектурах
- **Результати**: 
  - 32-біт: переповнення 19.01.2038 (4 байти)
  - 64-біт: переповнення через ~292 млрд років (8 байт)

## Завдання 2.2: Дослідження сегментів

- **Знахідки**:
  - Неініціалізований глобальний масив збільшує BSS сегмент
  - Ініціалізований глобальний масив збільшує сегмент даних
  - Локальні масиви не впливають на розмір файлу
  - Налагодження збільшує розмір файлу
  - Оптимізація зменшує текстовий сегмент

## Завдання 2.3: Розташування сегментів в пам'яті

- **Висновки**:
  - Стек розташований у високих адресах
  - Сегменти даних (.data, .bss) та код (.text) у низьких адресах
  - Куча розміщена між даними та стеком
  - Адресація залежить від ASLR та платформи

## Завдання 2.4: Дослідження стеку

- **Спостереження**:
  - Стек викликів читається від main до активної функції
  - Адреси локальних змінних зменшуються з кожним викликом
  - Стек зростає вниз
  - Системні компоненти різні на різних платформах

## Завдання 2.5: Теоретичне завдання про стек

- **Питання**: Чи можна обійтися без лічильника команд (IP), використовуючи вершину стека?
- **Висновок**: Теоретично можливо, але практично неефективно через:
  - Обмеження структури програми
  - Змішування даних та інструкцій
  - Проблеми продуктивності
  - Складність обробки винятків

## Завдання 19: Залежності ELF-файлів

- **Функціонал**: аналіз ELF-заголовка, динамічних залежностей, імпортованих символів
- **Порівняння**: 
  - FreeBSD - стандартні ELF-файли
  - CYGWIN - комбінація ELF та PE форматів

## Загальні висновки

Дослідження показало важливі особливості організації пам'яті процесу, розташування сегментів та структури виконуваних файлів на різних платформах, що критично для системного програмування та аналізу.