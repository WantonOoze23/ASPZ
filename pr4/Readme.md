# README: Практична робота 4 — malloc, realloc, calloc

## Загальна мета:
Ознайомитись з поведінкою функцій динамічного виділення пам’яті (`malloc`, `realloc`, `calloc`) в C, а також протестувати граничні випадки їх використання.

---

## Завдання 4.1 — Максимальна кількість пам’яті
У 64-бітній системі тип `size_t` займає 8 байт, тому теоретично `malloc` може виділити до `2^64` байт (≈ 18 ексабайт). Але на практиці — лише в межах доступної фізичної/віртуальної пам’яті. У 64-бітній архітектурі частина адресного простору зарезервована ОС, тому доступно лише ≈ 8 EB, а не 16 EB.

---

## ex2.c — Завдання 4.2
Код обчислює `num = xa * xb` де `xa` — від’ємне, `xb` — додатне. Якщо `num` типу `size_t`, знак не зберігається, але якщо `int`, відбувається **переповнення**. `malloc(num)` у такому разі може:
- повернути `NULL` (виділення не вдалося),
- або виділити менше пам’яті, ніж очікується.

Висновок: завжди використовуйте перевірку переповнення перед `malloc(xa * xb)`.

---

## ex3.c — Завдання 4.3
`malloc(0)`:
- **може повернути NULL**, або
- **вказівник, що можна безпечно звільнити (`free(ptr)`)**.

Це залежить від реалізації malloc (у glibc зазвичай повертається унікальний вказівник).

---

## ex4.c — Завдання 4.4
У циклі виділяється пам’ять, використовується, потім звільняється. Але:
- після `free(ptr)`, змінна `ptr` все ще не `NULL` і може призвести до **повторного використання звільненої пам’яті**.

**Правильний варіант**: після `free(ptr)` обов’язково зробити `ptr = NULL`.

---

## ex5.c — Завдання 4.5
`realloc(ptr, huge_size)`:
- Якщо не вдалося виділити пам’ять, `realloc` повертає `NULL`, але старий вказівник **не звільняється**.
- Потрібно перевіряти `new_ptr` та звільняти `ptr`, якщо `new_ptr == NULL`.

---

## ex6.c — Завдання 4.6
- `realloc(NULL, size)` ≡ `malloc(size)` — виділяє нову пам’ять.
- `realloc(ptr, 0)` ≡ `free(ptr)` — пам’ять звільняється, повертається NULL.

---

## ex7.c — Завдання 4.7
`reallocarray(ptr, n, size)` автоматично перевіряє на **переповнення при множенні** `n * size`, що не робить звичайний `realloc`.

**Перевага**: більша безпечність.  
Запуск через `ltrace` показує внутрішні виклики `calloc` / `reallocarray`.

---

## ex19.c — Додаткове завдання 19
Код виконує безкінечні спроби виділення великих обсягів пам’яті. В результаті:
- виникає **out-of-memory**,
- система може викликати **OOM Killer** і завершити процес.

---

## Висновок:
Усі приклади демонструють важливі аспекти використання `malloc` і пов'язаних функцій:
- перевірка переповнення,
- обережність із `realloc`,
- поведінка в особливих випадках (`malloc(0)`, `malloc(-1)`),
- використання `reallocarray` для захисту від integer overflow.

---
