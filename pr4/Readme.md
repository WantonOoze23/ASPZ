# README: Практична робота 4 — malloc, realloc, calloc

## Загальна мета:
Ознайомитись з поведінкою функцій динамічного виділення пам’яті (`malloc`, `realloc`, `calloc`) в C, а також протестувати граничні випадки їх використання.

---

## Відмінності між 32-бітною та 64-бітною системою:

| Характеристика                | 32-бітна система (x86)         | 64-бітна система (x86_64)        |
|------------------------------|-------------------------------|----------------------------------|
| Розмір `size_t`              | 4 байти (32 біти)             | 8 байт (64 біти)                |
| Теоретичний максимум malloc  | ~4 ГБ                         | ~16 ексабайт (2^64 байт)        |
| Практичний ліміт malloc      | До ~2-3 ГБ (через адресний простір) | Залежить від фізичної RAM і swap |
| Операції з великими числами  | Частіше переповнення          | Менше обмежень на розмір        |
| Поведінка при `xa * xb`      | Швидше призводить до переповнення int | size_t дозволяє уникнути цього |

> У 32-бітній системі значно швидше виникає переповнення або відмова у виділенні пам’яті, оскільки адресний простір обмежений. Наприклад, навіть `malloc(2 ГБ)` може завершитись невдачею.

---

## Завдання 4.1 — Максимальна кількість пам’яті
У 64-бітній системі `malloc` може приймати до `2^64` байт, оскільки параметр — це `size_t`. Але реально виділити таку кількість не вдасться: ОС і апаратне забезпечення обмежують доступну пам’ять. У 32-бітній системі — максимум близько 4 ГБ, але на практиці часто менше (~2–3 ГБ).

---

## ex2.c — Завдання 4.2
Код обчислює `num = xa * xb` де `xa` — від’ємне, `xb` — додатне. Якщо `num` типу `size_t`, знак не зберігається, але якщо `int`, відбувається **переповнення**. `malloc(num)` у такому разі може:
- повернути `NULL` (виділення не вдалося),
- або виділити менше пам’яті, ніж очікується.

Висновок: завжди використовуйте перевірку переповнення перед `malloc(xa * xb)`.

---

## ex3.c — Завдання 4.3
`malloc(0)`:
- **може повернути NULL**, або
- **вказівник, що можна безпечно звільнити (`free(ptr)`)**.

Це залежить від реалізації malloc (у glibc зазвичай повертається унікальний вказівник).  
Компіляцію та виконання можна прослідкувати через `ltrace ./ex3`.

---

## ex4.c — Завдання 4.4
У циклі виділяється пам’ять, використовується, потім звільняється. Але:
- після `free(ptr)`, змінна `ptr` все ще не `NULL` і може призвести до **повторного використання звільненої пам’яті**.

**Правильний варіант**: після `free(ptr)` обов’язково зробити `ptr = NULL`.

---

## ex5.c — Завдання 4.5
`realloc(ptr, huge_size)`:
- Якщо не вдалося виділити пам’ять, `realloc` повертає `NULL`, але старий вказівник **не звільняється**.
- Потрібно перевіряти `new_ptr` та звільняти `ptr`, якщо `new_ptr == NULL`.

---

## ex6.c — Завдання 4.6
- `realloc(NULL, size)` ≡ `malloc(size)` — виділяє нову пам’ять.
- `realloc(ptr, 0)` ≡ `free(ptr)` — пам’ять звільняється, повертається NULL.

---

## ex7.c — Завдання 4.7
`reallocarray(ptr, n, size)` автоматично перевіряє на **переповнення при множенні** `n * size`, що не робить звичайний `realloc`.

**Перевага**: більша безпечність.  
Запуск через `ltrace` показує внутрішні виклики `calloc` / `reallocarray`.

---

## ex19.c — Додаткове завдання 19
Код виконує безкінечні спроби виділення великих обсягів пам’яті. В результаті:
- виникає **out-of-memory**,
- система може викликати **OOM Killer** і завершити процес.

---

## Висновок:
Усі приклади демонструють важливі аспекти використання `malloc` і пов'язаних функцій:
- перевірка переповнення,
- обережність із `realloc`,
- поведінка в особливих випадках (`malloc(0)`, `malloc(-1)`),
- використання `reallocarray` для захисту від integer overflow.

**Особливу увагу слід звертати на архітектуру (x86 vs x86_64)** при тестуванні, оскільки розмір адресного простору напряму впливає на поведінку `malloc`.

---
